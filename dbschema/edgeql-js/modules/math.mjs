// GENERATED by @edgedb/generate v0.5.3

import * as $ from '../reflection.mjs';
import * as _ from '../imports.mjs';
function floor(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::floor', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000110', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000110'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::floor',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function ceil(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::ceil', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000110', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000110'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::ceil',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function abs(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::abs', args, _.spec, [
		{
			args: [{ typeId: '04976545-1176-5536-8673-c9f7d18d581b', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '04976545-1176-5536-8673-c9f7d18d581b'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::abs',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function ln(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::ln', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::ln',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function lg(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::lg', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::lg',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function log(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::log', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: false, variadic: false }],
			namedArgs: { base: { typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: false, variadic: false } },
			returnTypeId: '00000000-0000-0000-0000-000000000108'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::log',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function sqrt(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::sqrt', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: false, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::sqrt',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function mean(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::mean', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::mean',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function stddev(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::stddev', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::stddev',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function stddev_pop(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::stddev_pop', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::stddev_pop',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function var_0e9a1bf8ab9d5dc6830438e6ef6633fe(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::var', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff',
			returnTypemod: 'OptionalType'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108',
			returnTypemod: 'OptionalType'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::var',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

function var_pop(...args) {
	const {
		returnType,
		cardinality,
		args: positionalArgs,
		namedArgs
	} = _.syntax.$resolveOverload('math::var_pop', args, _.spec, [
		{
			args: [{ typeId: '00000000-0000-0000-0000-0000000001ff', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-0000000001ff',
			returnTypemod: 'OptionalType'
		},
		{
			args: [{ typeId: '00000000-0000-0000-0000-000000000108', optional: false, setoftype: true, variadic: false }],
			returnTypeId: '00000000-0000-0000-0000-000000000108',
			returnTypemod: 'OptionalType'
		}
	]);
	return _.syntax.$expressionify({
		__kind__: $.ExpressionKind.Function,
		__element__: returnType,
		__cardinality__: cardinality,
		__name__: 'math::var_pop',
		__args__: positionalArgs,
		__namedargs__: namedArgs
	});
}

const __defaultExports = {
	floor: floor,
	ceil: ceil,
	abs: abs,
	ln: ln,
	lg: lg,
	log: log,
	sqrt: sqrt,
	mean: mean,
	stddev: stddev,
	stddev_pop: stddev_pop,
	var: var_0e9a1bf8ab9d5dc6830438e6ef6633fe,
	var_pop: var_pop
};
export default __defaultExports;
