// GENERATED by @edgedb/generate v0.5.3

import * as $ from '../../reflection';
import * as _ from '../../imports';
import type * as _std from '../std';
export declare type $Base64Alphabet = {
	standard: $.$expr_Literal<$Base64Alphabet>;
	urlsafe: $.$expr_Literal<$Base64Alphabet>;
} & $.EnumType<'std::enc::Base64Alphabet', ['standard', 'urlsafe']>;
declare const Base64Alphabet: $Base64Alphabet;

declare type base64_encodeλFuncExpr<
	NamedArgs extends {
		alphabet?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>;
		padding?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>;
	},
	P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>
> = $.$expr_Function<
	_std.$str,
	$.cardutil.multiplyCardinalities<
		$.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.optionalParamCardinality<NamedArgs['alphabet']>>,
		$.cardutil.optionalParamCardinality<NamedArgs['padding']>
	>
>;
declare type base64_encodeλFuncExpr2<P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>> = $.$expr_Function<
	_std.$str,
	$.cardutil.paramCardinality<P1>
>;
/**
 * Encode given data as a base64 string
 */
declare function base64_encode<
	NamedArgs extends {
		alphabet?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>;
		padding?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>;
	},
	P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>
>(namedArgs: NamedArgs, data: P1): base64_encodeλFuncExpr<NamedArgs, P1>;
/**
 * Encode given data as a base64 string
 */
declare function base64_encode<P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$bytes>>>(data: P1): base64_encodeλFuncExpr2<P1>;

declare type base64_decodeλFuncExpr<
	NamedArgs extends {
		alphabet?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>;
		padding?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>;
	},
	P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>
> = $.$expr_Function<
	_std.$bytes,
	$.cardutil.multiplyCardinalities<
		$.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.optionalParamCardinality<NamedArgs['alphabet']>>,
		$.cardutil.optionalParamCardinality<NamedArgs['padding']>
	>
>;
declare type base64_decodeλFuncExpr2<P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>> = $.$expr_Function<
	_std.$bytes,
	$.cardutil.paramCardinality<P1>
>;
/**
 * Decode the byte64-encoded byte string and return decoded bytes.
 */
declare function base64_decode<
	NamedArgs extends {
		alphabet?: _.castMaps.orScalarLiteral<$.TypeSet<$Base64Alphabet>>;
		padding?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$bool>>;
	},
	P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>
>(namedArgs: NamedArgs, data: P1): base64_decodeλFuncExpr<NamedArgs, P1>;
/**
 * Decode the byte64-encoded byte string and return decoded bytes.
 */
declare function base64_decode<P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>>(data: P1): base64_decodeλFuncExpr2<P1>;

export { Base64Alphabet };

declare type __defaultExports = {
	Base64Alphabet: typeof Base64Alphabet;
	base64_encode: typeof base64_encode;
	base64_decode: typeof base64_decode;
};
declare const __defaultExports: __defaultExports;
export default __defaultExports;
