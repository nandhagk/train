// GENERATED by @edgedb/generate v0.5.3

import * as $ from '../reflection';
import * as _ from '../imports';
import type * as _std from './std';
export declare type $ElasticLanguage = {
	ara: $.$expr_Literal<$ElasticLanguage>;
	bul: $.$expr_Literal<$ElasticLanguage>;
	cat: $.$expr_Literal<$ElasticLanguage>;
	ces: $.$expr_Literal<$ElasticLanguage>;
	ckb: $.$expr_Literal<$ElasticLanguage>;
	dan: $.$expr_Literal<$ElasticLanguage>;
	deu: $.$expr_Literal<$ElasticLanguage>;
	ell: $.$expr_Literal<$ElasticLanguage>;
	eng: $.$expr_Literal<$ElasticLanguage>;
	eus: $.$expr_Literal<$ElasticLanguage>;
	fas: $.$expr_Literal<$ElasticLanguage>;
	fin: $.$expr_Literal<$ElasticLanguage>;
	fra: $.$expr_Literal<$ElasticLanguage>;
	gle: $.$expr_Literal<$ElasticLanguage>;
	glg: $.$expr_Literal<$ElasticLanguage>;
	hin: $.$expr_Literal<$ElasticLanguage>;
	hun: $.$expr_Literal<$ElasticLanguage>;
	hye: $.$expr_Literal<$ElasticLanguage>;
	ind: $.$expr_Literal<$ElasticLanguage>;
	ita: $.$expr_Literal<$ElasticLanguage>;
	lav: $.$expr_Literal<$ElasticLanguage>;
	nld: $.$expr_Literal<$ElasticLanguage>;
	nor: $.$expr_Literal<$ElasticLanguage>;
	por: $.$expr_Literal<$ElasticLanguage>;
	ron: $.$expr_Literal<$ElasticLanguage>;
	rus: $.$expr_Literal<$ElasticLanguage>;
	spa: $.$expr_Literal<$ElasticLanguage>;
	swe: $.$expr_Literal<$ElasticLanguage>;
	tha: $.$expr_Literal<$ElasticLanguage>;
	tur: $.$expr_Literal<$ElasticLanguage>;
	zho: $.$expr_Literal<$ElasticLanguage>;
	edb_Brazilian: $.$expr_Literal<$ElasticLanguage>;
	edb_ChineseJapaneseKorean: $.$expr_Literal<$ElasticLanguage>;
} & $.EnumType<
	'fts::ElasticLanguage',
	[
		'ara',
		'bul',
		'cat',
		'ces',
		'ckb',
		'dan',
		'deu',
		'ell',
		'eng',
		'eus',
		'fas',
		'fin',
		'fra',
		'gle',
		'glg',
		'hin',
		'hun',
		'hye',
		'ind',
		'ita',
		'lav',
		'nld',
		'nor',
		'por',
		'ron',
		'rus',
		'spa',
		'swe',
		'tha',
		'tur',
		'zho',
		'edb_Brazilian',
		'edb_ChineseJapaneseKorean'
	]
>;
declare const ElasticLanguage: $ElasticLanguage;

export declare type $Language = {
	ara: $.$expr_Literal<$Language>;
	hye: $.$expr_Literal<$Language>;
	eus: $.$expr_Literal<$Language>;
	cat: $.$expr_Literal<$Language>;
	dan: $.$expr_Literal<$Language>;
	nld: $.$expr_Literal<$Language>;
	eng: $.$expr_Literal<$Language>;
	fin: $.$expr_Literal<$Language>;
	fra: $.$expr_Literal<$Language>;
	deu: $.$expr_Literal<$Language>;
	ell: $.$expr_Literal<$Language>;
	hin: $.$expr_Literal<$Language>;
	hun: $.$expr_Literal<$Language>;
	ind: $.$expr_Literal<$Language>;
	gle: $.$expr_Literal<$Language>;
	ita: $.$expr_Literal<$Language>;
	nor: $.$expr_Literal<$Language>;
	por: $.$expr_Literal<$Language>;
	ron: $.$expr_Literal<$Language>;
	rus: $.$expr_Literal<$Language>;
	spa: $.$expr_Literal<$Language>;
	swe: $.$expr_Literal<$Language>;
	tur: $.$expr_Literal<$Language>;
} & $.EnumType<
	'fts::Language',
	[
		'ara',
		'hye',
		'eus',
		'cat',
		'dan',
		'nld',
		'eng',
		'fin',
		'fra',
		'deu',
		'ell',
		'hin',
		'hun',
		'ind',
		'gle',
		'ita',
		'nor',
		'por',
		'ron',
		'rus',
		'spa',
		'swe',
		'tur'
	]
>;
declare const Language: $Language;

export declare type $LuceneLanguage = {
	ara: $.$expr_Literal<$LuceneLanguage>;
	ben: $.$expr_Literal<$LuceneLanguage>;
	bul: $.$expr_Literal<$LuceneLanguage>;
	cat: $.$expr_Literal<$LuceneLanguage>;
	ces: $.$expr_Literal<$LuceneLanguage>;
	ckb: $.$expr_Literal<$LuceneLanguage>;
	dan: $.$expr_Literal<$LuceneLanguage>;
	deu: $.$expr_Literal<$LuceneLanguage>;
	ell: $.$expr_Literal<$LuceneLanguage>;
	eng: $.$expr_Literal<$LuceneLanguage>;
	est: $.$expr_Literal<$LuceneLanguage>;
	eus: $.$expr_Literal<$LuceneLanguage>;
	fas: $.$expr_Literal<$LuceneLanguage>;
	fin: $.$expr_Literal<$LuceneLanguage>;
	fra: $.$expr_Literal<$LuceneLanguage>;
	gle: $.$expr_Literal<$LuceneLanguage>;
	glg: $.$expr_Literal<$LuceneLanguage>;
	hin: $.$expr_Literal<$LuceneLanguage>;
	hun: $.$expr_Literal<$LuceneLanguage>;
	hye: $.$expr_Literal<$LuceneLanguage>;
	ind: $.$expr_Literal<$LuceneLanguage>;
	ita: $.$expr_Literal<$LuceneLanguage>;
	lav: $.$expr_Literal<$LuceneLanguage>;
	lit: $.$expr_Literal<$LuceneLanguage>;
	nld: $.$expr_Literal<$LuceneLanguage>;
	nor: $.$expr_Literal<$LuceneLanguage>;
	por: $.$expr_Literal<$LuceneLanguage>;
	ron: $.$expr_Literal<$LuceneLanguage>;
	rus: $.$expr_Literal<$LuceneLanguage>;
	spa: $.$expr_Literal<$LuceneLanguage>;
	srp: $.$expr_Literal<$LuceneLanguage>;
	swe: $.$expr_Literal<$LuceneLanguage>;
	tha: $.$expr_Literal<$LuceneLanguage>;
	tur: $.$expr_Literal<$LuceneLanguage>;
	edb_Brazilian: $.$expr_Literal<$LuceneLanguage>;
	edb_ChineseJapaneseKorean: $.$expr_Literal<$LuceneLanguage>;
	edb_Indian: $.$expr_Literal<$LuceneLanguage>;
} & $.EnumType<
	'fts::LuceneLanguage',
	[
		'ara',
		'ben',
		'bul',
		'cat',
		'ces',
		'ckb',
		'dan',
		'deu',
		'ell',
		'eng',
		'est',
		'eus',
		'fas',
		'fin',
		'fra',
		'gle',
		'glg',
		'hin',
		'hun',
		'hye',
		'ind',
		'ita',
		'lav',
		'lit',
		'nld',
		'nor',
		'por',
		'ron',
		'rus',
		'spa',
		'srp',
		'swe',
		'tha',
		'tur',
		'edb_Brazilian',
		'edb_ChineseJapaneseKorean',
		'edb_Indian'
	]
>;
declare const LuceneLanguage: $LuceneLanguage;

export declare type $PGLanguage = {
	xxx_simple: $.$expr_Literal<$PGLanguage>;
	ara: $.$expr_Literal<$PGLanguage>;
	hye: $.$expr_Literal<$PGLanguage>;
	eus: $.$expr_Literal<$PGLanguage>;
	cat: $.$expr_Literal<$PGLanguage>;
	dan: $.$expr_Literal<$PGLanguage>;
	nld: $.$expr_Literal<$PGLanguage>;
	eng: $.$expr_Literal<$PGLanguage>;
	fin: $.$expr_Literal<$PGLanguage>;
	fra: $.$expr_Literal<$PGLanguage>;
	deu: $.$expr_Literal<$PGLanguage>;
	ell: $.$expr_Literal<$PGLanguage>;
	hin: $.$expr_Literal<$PGLanguage>;
	hun: $.$expr_Literal<$PGLanguage>;
	ind: $.$expr_Literal<$PGLanguage>;
	gle: $.$expr_Literal<$PGLanguage>;
	ita: $.$expr_Literal<$PGLanguage>;
	lit: $.$expr_Literal<$PGLanguage>;
	npi: $.$expr_Literal<$PGLanguage>;
	nor: $.$expr_Literal<$PGLanguage>;
	por: $.$expr_Literal<$PGLanguage>;
	ron: $.$expr_Literal<$PGLanguage>;
	rus: $.$expr_Literal<$PGLanguage>;
	srp: $.$expr_Literal<$PGLanguage>;
	spa: $.$expr_Literal<$PGLanguage>;
	swe: $.$expr_Literal<$PGLanguage>;
	tam: $.$expr_Literal<$PGLanguage>;
	tur: $.$expr_Literal<$PGLanguage>;
	yid: $.$expr_Literal<$PGLanguage>;
} & $.EnumType<
	'fts::PGLanguage',
	[
		'xxx_simple',
		'ara',
		'hye',
		'eus',
		'cat',
		'dan',
		'nld',
		'eng',
		'fin',
		'fra',
		'deu',
		'ell',
		'hin',
		'hun',
		'ind',
		'gle',
		'ita',
		'lit',
		'npi',
		'nor',
		'por',
		'ron',
		'rus',
		'srp',
		'spa',
		'swe',
		'tam',
		'tur',
		'yid'
	]
>;
declare const PGLanguage: $PGLanguage;

export declare type $Weight = {
	A: $.$expr_Literal<$Weight>;
	B: $.$expr_Literal<$Weight>;
	C: $.$expr_Literal<$Weight>;
	D: $.$expr_Literal<$Weight>;
} & $.EnumType<'fts::Weight', ['A', 'B', 'C', 'D']>;
declare const Weight: $Weight;

export declare type $document = $.ScalarType<'fts::document', unknown>;
declare const document: $.scalarTypeWithConstructor<$document, never>;

declare type with_optionsλFuncExpr<
	NamedArgs extends {
		language: _.castMaps.orScalarLiteral<$.TypeSet<$.EnumType>>;
		weight_category?: _.castMaps.orScalarLiteral<$.TypeSet<$Weight>>;
	},
	P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>
> = $.$expr_Function<
	$document,
	$.cardutil.multiplyCardinalities<
		$.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<NamedArgs['language']>>,
		$.cardutil.optionalParamCardinality<NamedArgs['weight_category']>
	>
>;
/**
 * 
        Adds language and weight category information to a string,
        so it be indexed with fts::index.
    
 */
declare function with_options<
	NamedArgs extends {
		language: _.castMaps.orScalarLiteral<$.TypeSet<$.EnumType>>;
		weight_category?: _.castMaps.orScalarLiteral<$.TypeSet<$Weight>>;
	},
	P1 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>
>(namedArgs: NamedArgs, text: P1): with_optionsλFuncExpr<NamedArgs, P1>;

declare type searchλFuncExpr<
	NamedArgs extends {
		language?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>;
		weights?: $.TypeSet<$.ArrayType<_std.$float64>>;
	},
	P1 extends $.TypeSet<$.AnyObjectType>,
	P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>
> = $.$expr_Function<
	$.NamedTupleType<{ object: $.AnyObjectType; score: _std.$float32 }>,
	$.cardutil.overrideLowerBound<
		$.cardutil.multiplyCardinalities<
			$.cardutil.multiplyCardinalities<
				$.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>,
				$.cardutil.optionalParamCardinality<NamedArgs['language']>
			>,
			$.cardutil.optionalParamCardinality<NamedArgs['weights']>
		>,
		'Zero'
	>
>;
declare type searchλFuncExpr2<P1 extends $.TypeSet<$.AnyObjectType>, P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>> = $.$expr_Function<
	$.NamedTupleType<{ object: $.AnyObjectType; score: _std.$float32 }>,
	$.cardutil.overrideLowerBound<$.cardutil.multiplyCardinalities<$.cardutil.paramCardinality<P1>, $.cardutil.paramCardinality<P2>>, 'Zero'>
>;
/**
 * 
        Search an object using its fts::index index.
        Returns objects that match the specified query and the matching score.
    
 */
declare function search<
	NamedArgs extends {
		language?: _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>;
		weights?: $.TypeSet<$.ArrayType<_std.$float64>>;
	},
	P1 extends $.TypeSet<$.AnyObjectType>,
	P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>
>(namedArgs: NamedArgs, object: P1, query: P2): searchλFuncExpr<NamedArgs, P1, P2>;
/**
 * 
        Search an object using its fts::index index.
        Returns objects that match the specified query and the matching score.
    
 */
declare function search<P1 extends $.TypeSet<$.AnyObjectType>, P2 extends _.castMaps.orScalarLiteral<$.TypeSet<_std.$str>>>(
	object: P1,
	query: P2
): searchλFuncExpr2<P1, P2>;

export { ElasticLanguage, Language, LuceneLanguage, PGLanguage, Weight, document };

declare type __defaultExports = {
	ElasticLanguage: typeof ElasticLanguage;
	Language: typeof Language;
	LuceneLanguage: typeof LuceneLanguage;
	PGLanguage: typeof PGLanguage;
	Weight: typeof Weight;
	document: typeof document;
	with_options: typeof with_options;
	search: typeof search;
};
declare const __defaultExports: __defaultExports;
export default __defaultExports;
